import express, { NextFunction, Request, Response } from "express";
import swaggerUI from "swagger-ui-express";
import swaggerJSDoc from "swagger-jsdoc";
import moment from "moment";
import { google, lucia } from "./src/auth";
import { db } from "./src/db";
import {
  BookingTable,
  DaysEnum,
  DoctorTable,
  DoctorsAvailability,
  PatientReports,
  PatientTable,
  userTable,
} from "./src/schema";
import { and, between, eq } from "drizzle-orm";
import { Session, User, generateIdFromEntropySize } from "lucia";
import multar from "multer";
import { formatInTimeZone } from "date-fns-tz";
import expressJSDocSwagger, { Options } from "express-jsdoc-swagger";
import { OAuth2RequestError } from "arctic";
import morgan from "morgan";
import cors from "cors";
import DotEnv from "dotenv";
DotEnv.config();
const StartTime = new Date();

const App = express();
const FrontendURL = process.env.FRONTEND_URL;
if (FrontendURL == undefined) {
  console.warn("No Frontend URL detected Exiting");
  process.exit(0);
}

App.use("/files", express.static("uploads"));

App.use(
  cors({
    credentials: true,
    origin: FrontendURL,
  })
);

App.use(morgan("combined"));

const SwaggerOption: Options = {
  info: {
    description:
      "AutoGenerated API Docs for Doctor Appointment System api-collection available at /api-docs.json",

    version: "1.0.0",
    title: "Doctor Appointment",
  },
  exposeApiDocs: true,
  apiDocsPath: "/api-docs.json",

  swaggerUiOptions: {
    customCss: ".swagger-ui .topbar .topbar-wrapper { visibility: hidden }",
    customSiteTitle: "Doctor Appointment System",
    customfavIcon: "/favicon.ico",
  },
  security: {
    bearerAuth: {
      type: "http",
      scheme: "bearer",
    },
  },
  servers: [
    {
      url: "https://api.jaay.fun",
      description: "Development Server",
    },
  ],
  baseDir: __dirname,
  filesPattern: "*.ts",
  swaggerUIPath: "/api-docs",
};

expressJSDocSwagger(App)(SwaggerOption);

const upload = multar({
  storage: multar.diskStorage({
    filename: function (req, file, cb) {
      cb(null, Date.now() + ".pdf"); //Appending .jpg
    },
    destination: function (req, file, cb) {
      cb(null, "uploads/");
    },
  }),
});

App.use(express.json());
App.use(express.urlencoded({ extended: true }));
// login User
/**
 * GET /login
 * @summary Create a Login Session for User
 * @tags Authentication
 * @return 200 - Return Google Login URL Based on Predefined Scope Access
 */
App.get("/login", async (req, res) => {
  // TODO: implement state control
  const googleAuthURL = await google.createAuthorizationURL("", "dhan", {
    scopes: ["profile", "email"],
  });
  res.redirect(googleAuthURL.toString());
  // res.json({
  //   url: googleAuthURL.toString(),
  // });
});

// login User
/**
 * GET /logout
 * @summary Create a Login Session for User
 * @tags Authentication
 * @return 200 - Return Google Login URL Based on Predefined Scope Access
 * @security bearerAuth
 */
App.get("/logout", AuthenticatedRequest, async (req, res) => {
  await lucia.invalidateSession(req.Session.id);
  res.json({
    message: "Logged Out",
  });
  // TODO: implement state control
  // res.json({
  //   url: googleAuthURL.toString(),
  // });
});

/**
 * GET /callback
 * @summary PostLogin Callback
 * @tags Authentication
 * @return 200 - Successful Response Redirects users to Frontend
 */
App.get("/callback", async (req, res) => {
  const props = req.query as {
    code: string;
    scope: string;
    authuser: string;
    prompt: string;
  };

  try {
    const tokens = await google.validateAuthorizationCode(props.code, "dhan");
    const response = await fetch(
      "https://openidconnect.googleapis.com/v1/userinfo",
      {
        headers: {
          Authorization: `Bearer ${tokens.accessToken}`,
        },
      }
    );
    const user = (await response.json()) as {
      sub: string;
      name: string;
      given_name: string;
      family_name: string;
      picture: string;
      email: string;
      email_verified: boolean;
      locale: string;
    };

    const ExitingUser = await db
      .select()
      .from(userTable)
      .where(eq(userTable.user_sub, user.sub));

    if (ExitingUser.length == 0) {
      const userId = generateIdFromEntropySize(10);
      const InsertedUser = await db.insert(userTable).values({
        id: userId,
        user_sub: user.sub,
        email: user.email,
        givenName: user.given_name,
        familyName: user.family_name,
        picture: user.picture,
      });
      const session = await lucia.createSession(userId, {});
      const SessionID = session.id;
      // Send Back this Response to Client to Store
      // res.redirect(`http://localhost:3000?session=${SessionID}`);
      // res.json(session);
      const Cookie = lucia.createSessionCookie(SessionID);
      res.appendHeader("Set-Cookie", Cookie.serialize());
      res.redirect(FrontendURL + "/redirect?logged");

      // User is New
    } else {
      const session = await lucia.createSession(ExitingUser[0].id, {});
      const SessionID = session.id;
      // Send Back this Response to Client to Store
      // res.redirect(`http://localhost:3000?session=${SessionID}`);
      // res.json(session);
      const Cookie = lucia.createSessionCookie(SessionID);
      res.appendHeader("Set-Cookie", Cookie.serialize());
      res.redirect(FrontendURL + "/redirect?logged");
      // User is Old
    }
  } catch (e) {
    if (e instanceof OAuth2RequestError) {
      return res.status(400).json({
        message: "Oauth2 validation Error",
      });
    }

    return res.status(500).json({
      message: "Internal Server Error",
    });
  }
});

/**
 * GET /profile
 * @summary View internal profile of User
 * @tags Doctors - Doctors Profile
 * @tags Patients - Patients Profile
 * @return {object} 200 - Successful Response Redirects users to Frontend
 * @example response - 200 - Suucessful Response
 * {
    "Email": "hello@dhananjay",
    "Firstname": "Dhananjay",
    "LastName": null,
    "Picture": "sameple-picture",
    "RegisteredAt": "2024-05-07T05:31:37.957Z",
    "Type": "patient"
}
* @return 400 - Unauthenticated Request
* @return 401 - Unauthorized Request
 * @security bearerAuth
 */
App.get("/profile", AuthenticatedRequest, (req, res) => {
  const UserType = {
    ...req.User,
  };
  res.json({
    Email: UserType.Email,
    Firstname: UserType.Firstname,
    LastName: UserType.LastName,
    Picture: UserType.Picture,
    RegisteredAt: UserType.CreatedAt,
    Type: UserType.ProfileType,
  });
});

/**
 * GET /health
 * @summary Health Check
 * @tags server
 * @return {object} 200 - Server is Up and Running
 * @example response - 200 - Suucessful Response
 * {
 * "status": "ONLINE",
 * "startedAt": "2024-05-07T08:16:53.371Z",
 * "version": "1.0.0",
 * "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
 * }
 * @returns 500 - Internal Server Error
 */
App.get("/health", (req, res) => {
  res.json({
    status: "ONLINE",
    startedAt: StartTime,
    version: "1.0.0",
    userAgent: req.headers["user-agent"],
  });
});
/**
 * GET /doctor/status
 * @summary Check Weather the Doctors have been Approved or Not by Admin
 * @tags Doctors - Doctors Profile
  * @security bearerAuth
 * @return {object} 200 - Server is Up and Running
 * @example response - 200 - Approved
{
    "status": "approved"
}
@security bearerAuth
 * @example response - 200 - Pending
{
    "status": "pending"
}
 * @returns 500 - Internal Server Error
 */
App.get("/doctor/status", AuthenticatedRequest, async (req, res) => {
  const Doctor = await db
    .select()
    .from(DoctorTable)
    .where(eq(DoctorTable.user_id, req.User.id));
  if (Doctor.length == 0) {
    res.json({
      status: "NOT_REGISTERED",
    });
  } else {
    res.json({
      status: Doctor[0].status,
    });
  }
});

/**
 * A Patient Form
 * @typedef {object} PatientData
 * @property {string} reports.required - The Previos Mediacal Reports - binary
 * @property {string} previous_diseases.required - History of Previos Dieseases
 * @property {string} age.required - Age of Patient
 */

/**
 * POST /user/register
 * @summary Mark Newsly Register User as Patient
 * @tags Patients - Patients Profile
 * @param {PatientData} request.body.required - Patient Bio Data - multipart/form-data
 * @return {object} 200 - User Has been registered as Patient
 * @return {object} 400 - User Already Registered
 * @example response - 400 - Already Registered
{
    "message": "User Already Registered"
}
@security bearerAuth
 * @example response - 200 - Registered
{
    "message": "Registration Sucessful"
}
 * @returns 500 - Internal Server Error
 */
App.post(
  "/user/register",
  AuthenticatedRequest,
  upload.array("reports"),
  async (req, res) => {
    // Check if the user is already registered
    if (req.User.ProfileType != null) {
      res.status(400).json({
        message: "User Already Registered",
      });
      return;
    } else {
      const BodyData = req.body as {
        age: string;
        previous_diseases: string;
      };

      // Check if the request is valid
      // files , age , previousDiseases

      if (!BodyData.age || !BodyData.previous_diseases || !req.files) {
        res.status(400).json({
          message: "Invalid Request , required fields are missing",
        });
      } else {
        // Get All Files
        const Reportsfiles = req.files as Express.Multer.File[];
        const PatientInsrt = await db.insert(PatientTable).values({
          age: +BodyData.age,
          previousDiseases: BodyData.previous_diseases,
          user_id: req.User.id,
        });
        const UserUpdate = await db
          .update(userTable)
          .set({
            userType: "patient",
          })
          .where(eq(userTable.id, req.User.id));
        const ReportsInsert = await db.insert(PatientReports).values(
          Reportsfiles.map((reportId) => ({
            user_id: req.User.id,
            report: reportId.filename,
          }))
        );
        if (
          PatientInsrt.rowCount > 0 &&
          UserUpdate.rowCount > 0 &&
          ReportsInsert.rowCount > 0
        ) {
          res.status(201).json({
            message: "User Registered Successfully",
          });
        } else {
          res.status(500).json({
            message: "Internal Server Error",
          });
        }
      }
    }
  }
);
/**
 * GET /user/doctors
 * @summary Get List of Approved Doctors
 * @security bearerAuth
 * @tags Patients - Patients Profile
 * @return {object} 200 - Server is Up and Running
 * @example response - 200 - Doctors List
[
    {
        "doctor_id": "mffazwwqdubiwo2z",
        "doctor_firstName": "Dhananjay",
        "doctor_lastName": "Senday",
        "doctor_joinedAt": "2024-05-06T21:03:04.038Z",
        "doctor_speciality": "Eye Specilist",
        "doctor_experience": "2Year",
        "doctor_about": "I am doctor of new ",
        "doctor_rating": 0
    }
]
@security bearerAuth
 * @returns 500 - Internal Server Error
 */
App.get("/user/doctors", AuthenticatedRequest, async (req, res) => {
  let ApprovedDoctors = await db
    .select()
    .from(DoctorTable)
    .where(eq(DoctorTable.status, "approved"))
    .innerJoin(userTable, eq(DoctorTable.user_id, userTable.id));
  res.json(
    ApprovedDoctors.map((data) => {
      return {
        doctor_id: data.user.id,
        doctor_firstName: data.user.givenName,
        doctor_lastName: data.user.familyName,
        doctor_joinedAt: data.user.createdAt,
        doctor_speciality: data.doctor.speciality,
        doctor_experience: data.doctor.experience,
        doctor_about: data.doctor.about,
        doctor_rating: data.doctor.rating,
        doctor_pic: data.user.picture,
      };
    })
  );

  // TODO: FIX:
});
/**
 * GET /user/doctors/{doctorId}/slots
 * @security bearerAuth
 * @summary Get List of Available Slots for Doctor
 * @param {string} doctorId.path.required - Get List of Available Slots for Doctor
 * @return {object} 200 - success response
  * @example response - 200 - Doctors Slot List
[
    {
        "day": "Tuesday",
        "startTime": "10:00 AM",
        "endTime": "8:20 PM",
        "isAvailable": true
    },
    {
        "day": "Wednesday",
        "startTime": "10:00 AM",
        "endTime": "8:20 PM",
        "isAvailable": true
    },
    {
        "day": "Thursday",
        "startTime": "10:00 AM",
        "endTime": "8:20 PM",
        "isAvailable": true
    },
    {
        "day": "Friday",
        "startTime": "10:00 AM",
        "endTime": "8:20 PM",
        "isAvailable": true
    },
    {
        "day": "Saturday",
        "startTime": "10:00 AM",
        "endTime": "8:20 PM",
        "isAvailable": true
    },
    {
        "day": "Monday",
        "startTime": "8:90",
        "endTime": "10:10",
        "isAvailable": false
    }
]
 * @tags Patients - Patients Profile
 */
App.get(
  "/user/doctors/:doctorId/slots",
  AuthenticatedRequest,
  async (req, res) => {
    const DoctorId = req.params.doctorId;
    if (!DoctorId) {
      res.status(400).json({
        message: "Invalid Request , Doctor Id is Missing",
      });
      return;
    }

    const DoctorSlots = await db
      .select()
      .from(DoctorsAvailability)
      .where(eq(DoctorsAvailability.doctor_id, DoctorId));

    res.json(
      DoctorSlots.map((data) => {
        return {
          day: data.day,
          startTime: data.startTime,
          endTime: data.endTime,
          isAvailable: data.isAvailable,
        };
      })
    );
  }
);
// TODO: Book Appointment
// payload example
// {
//   "doctorId": "123",
//   "day": "monday",
//   "time": "10:00"
// }
// Logic -> Check if the slot is available
// Only Book if the slot is available\
// Check if the user has already booked the slot
// If the user has already booked the slot
// return error
// else book the slot

/**
 * POST /user/doctors/:doctorId/slots
 * @summary Book Slot with Doctor
 * @description Book an Appointment with Doctor with Speicifc Slot and Time Send TODO: Trigger Email Events and Notification 
 * @tags Patients - Patients Profile
 * @security bearerAuth
 * @param {string} doctorId.path.required - Get List of Available Slots for Doctor
 * @param {string} slot-time.form.required - Slot Timing To Register Eg : 2024-05-16T07:41  - application/x-www-form-urlencoded
 * @returns {object} 200 - Appointment Booked Successfully
 * @example response - 200 - Appointment Booked Successfully
 * {
    "message": "Appomitment Booked Suuccessfully"
}
@return {object} 400 - You already have an appointment at this time
@example response - 400 - You already have an appointment at this time
{
    "message": "You already have an appointment at this time"
}
 */

App.post(
  "/user/doctors/:doctorId/slots",
  AuthenticatedRequest,
  async (req, res) => {
    const RequesBody = req.body as {
      "slot-time": string;
    };

    const DoctorId = req.params.doctorId;
    const MomentParsed = moment(RequesBody["slot-time"]);
    // console.log(RequesBody["slot-time"]);
    // check that the user doesn't have any appointment at the same time with any doctor
    const userAppointments = await db
      .select()
      .from(BookingTable)
      .where(
        and(
          eq(BookingTable.patient_id, req.User.id),
          eq(BookingTable.dateAndTime, MomentParsed.toDate())
        )
      );

    if (userAppointments.length > 0) {
      res.status(400).json({
        message: "You already have an appointment at this time",
      });
      return;
    } else {
      // Create the appointment
      const AppointmentInsert = await db.insert(BookingTable).values({
        doctor_id: DoctorId,
        patient_id: req.User.id,
        dateAndTime: MomentParsed.toDate(),
      });
      if (AppointmentInsert.rowCount > 0) {
        res.status(201).json({
          message: "Appointment Booked Successfully",
        });
        // TODO: Send Notification to Doctor
        // Send Email to Both Doctor and Patient
        // Create a Appointment in Users Google Calendar
        // TODO:
      } else {
        res.status(500).json({
          message: "Internal Server Error",
        });
      }
    }
  }
);

/**
 * GET /doctors/appointments
  * @security bearerAuth
  * @summary Get List of Appointments for Doctor
 * @description Doctors can view all their appointments , Server Calculate the The Appointment of Current Week Only
 * @tags Doctors - Doctors Profile
 * @returns {object} 200 - Appointment List
 * @example response - 200 - Example 1
[
    {
        "id": 1,
        "displayImage": "sample_image_url",
        "patient_id": "random_id",
        "patient_firstName": "Dhananjay",
        "patient_lastName": null,
        "appointment_date": "2024-05-16 07:41:00 IST"
    }
]
 */

App.get("/doctors/appointments", AuthenticatedRequest, async (req, res) => {
  if (req.User.ProfileType != "doctor") {
    res.status(400).json({
      message: "Tu Bsdk Doctor Nahi Hai Gand Mara Raha Hai",
    });
    return;
  } else {
    // Get Server Time Frame
    const startOfWeek = moment().startOf("week").toDate();
    const endOfWeek = moment().endOf("week").toDate();

    const DoctorAppointments = await db
      .select()
      .from(BookingTable)
      .where(
        and(
          eq(BookingTable.doctor_id, req.User.id),
          between(BookingTable.dateAndTime, startOfWeek, endOfWeek)
        )
      )
      .innerJoin(userTable, eq(BookingTable.patient_id, userTable.id));
    let Apponintments = DoctorAppointments;
    res.json(
      Apponintments.map((data) => {
        const date = new Date(data.booking.dateAndTime);
        return {
          id: data.booking.Serials,
          displayImage: data.user.picture,
          patient_id: data.user.id,
          patient_firstName: data.user.givenName,
          patient_lastName: data.user.familyName,
          appointment_date: date,
        };
      })
    );
  }
});

/**
 * Doctor Availability
 * @typedef {object} DocAvailability
 * @property {string} start.required - Start Time
 * @property {string} end - End Time
 * @property {string} isAvailable - Availability
 */

/**
 * PATCH /doctor/slots/:day
 * @security bearerAuth
 * @description Update Doctor Slot for Specific Day (make sure days are in small case)
 * @summary Update Slot Availability for Doctor
 * @tags Doctors - Doctors Profile
  * @param {string} day.path.required - All Days in Small Case - enum:monday,tuesday,wednesday,thursday,friday,saturday
 * @param {DocAvailability} request.body.required - songs info - application/json
 * @returns {object} 200 - Appointment List
 * @example response - 200 - Example 1
{
    "message": "Slot Updated Successfully for monday"
}
 */
App.patch("/doctor/slots/:day", AuthenticatedRequest, async (req, res) => {
  if (req.User.ProfileType != "doctor") {
    res.status(400).json({
      message: "Tu Bsdk Doctor Nahi Hai Gand Mara Raha Hai",
    });
    return;
  } else {
    const body = req.body as {
      start: string;
      end: string;
      isAvailable: boolean;
    };
    let Day = req.params.day as
      | "monday"
      | "tuesday"
      | "wednesday"
      | "thursday"
      | "friday"
      | "saturday";

    const DoctorSlotUpdate = await db
      .update(DoctorsAvailability)
      .set({
        startTime: body.start,
        endTime: body.end,
        isAvailable: body.isAvailable,
      })
      .where(
        and(
          eq(DoctorsAvailability.doctor_id, req.User.id),
          eq(
            DoctorsAvailability.day,
            Day == "monday"
              ? "Monday"
              : Day == "tuesday"
              ? "Tuesday"
              : Day == "wednesday"
              ? "Wednesday"
              : Day == "thursday"
              ? "Thursday"
              : Day == "friday"
              ? "Friday"
              : "Saturday"
          )
        )
      );
    if (DoctorSlotUpdate.rowCount > 0) {
      res.json({
        message: "Slot Updated Successfully for " + Day,
      });
    } else {
      res.status(500).json({
        message: "Internal Server Error",
      });
    }
  }
});
/**
 * POST /doctor/slots
 * @security bearerAuth
 * @summary Set Availability Slot for Newly Registered Doctor
 * @description   Set Doctor Slot for All Days
 * @tags Doctors - Doctors Profile
 * @param {object} request.body.required - songs info - application/json TODO:
 * @example request - Example - Example 1
 * {
    "monday": {
        "start": "10:00 AM",
        "end": "8:20 PM"
    },
    "tuesday": {
        "start": "10:00 AM",
        "end": "8:20 PM"
    },
    "wednesday": {
        "start": "10:00 AM",
        "end": "8:20 PM"
    },
    "thursday": {
        "start": "10:00 AM",
        "end": "8:20 PM"
    },
    "friday": {
        "start": "10:00 AM",
        "end": "8:20 PM"
    },
    "saturday": {
        "start": "10:00 AM",
        "end": "8:20 PM"
    }
}
 * @returns {object} 200 - Appointment List
 * @example response - 200 - Example 1
{
    "message": "Slots Added Successfullt"
}
 * @returns {object} 400 - Appointment List
 * @example response - 400 - Example 1
{
    "message": "Slots Already Added , Update Them Instead"
}
 */
App.post("/doctor/slots", AuthenticatedRequest, async (req, res) => {
  if (req.User.ProfileType != "doctor") {
    res.status(400).json({
      message: "Tu Bsdk Doctor Nahi Hai Gand Mara Raha Hai",
    });
    return;
  } else {
    const AlreadyAvailableSlots = await db
      .select()
      .from(DoctorsAvailability)
      .where(eq(DoctorsAvailability.doctor_id, req.User.id));
    if (AlreadyAvailableSlots.length > 0) {
      res.status(400).json({
        message: "Slots Already Added , Update Them Instead",
      });
      return;
    }

    const body = req.body as {
      monday: {
        start: string;
        end: string;
      };
      tuesday: {
        start: string;
        end: string;
      };
      wednesday: {
        start: string;
        end: string;
      };
      thursday: {
        start: string;
        end: string;
      };
      friday: {
        start: string;
        end: string;
      };
      saturday: {
        start: string;
        end: string;
      };
      sunday: {
        start: string;
        end: string;
      };
    };

    const MondayInsert = await db.insert(DoctorsAvailability).values({
      doctor_id: req.User.id,
      day: "Monday",
      startTime: body.monday.start,
      endTime: body.monday.end,
    });
    const TuesdayInsert = await db.insert(DoctorsAvailability).values({
      doctor_id: req.User.id,
      day: "Tuesday",
      startTime: body.tuesday.start,
      endTime: body.tuesday.end,
    });
    const WednesdayInsert = await db.insert(DoctorsAvailability).values({
      doctor_id: req.User.id,
      day: "Wednesday",
      startTime: body.wednesday.start,
      endTime: body.wednesday.end,
    });
    const ThursdayInsert = await db.insert(DoctorsAvailability).values({
      doctor_id: req.User.id,
      day: "Thursday",
      startTime: body.thursday.start,
      endTime: body.thursday.end,
    });
    const FridayInsert = await db.insert(DoctorsAvailability).values({
      doctor_id: req.User.id,
      day: "Friday",
      startTime: body.friday.start,
      endTime: body.friday.end,
    });
    const SaturdayInsert = await db.insert(DoctorsAvailability).values({
      doctor_id: req.User.id,
      day: "Saturday",
      startTime: body.saturday.start,
      endTime: body.saturday.end,
    });

    if (
      MondayInsert.rowCount > 0 &&
      TuesdayInsert.rowCount > 0 &&
      WednesdayInsert.rowCount > 0 &&
      ThursdayInsert.rowCount > 0 &&
      FridayInsert.rowCount > 0 &&
      SaturdayInsert.rowCount > 0
    ) {
      res.status(201).json({
        message: "Slots Added Successfully",
      });
    } else {
      res.status(500).json({
        message: "Internal Server Error",
      });
    }
  }
});

// Register Doctor

/**
 * A Doctors Object
 * @typedef {object} DoctorSchema
 * @property {string} pdfFile.required - Data Containing Degree or Proof
 * @property {string} speciality.required - Doctor Speciality
 * @property {string} experience.required - Doctor Experience
 * @property {string} about.required - About Doctor
 */

/**
 * POST /doctor/register
 * @summary Mark Newsly Register User as Doctor in Pending State
 * @tags Doctors - Doctors Profile
 * @param {DoctorSchema} request.body.required - Patient Bio Data - multipart/form-data
 * @return {object} 200 - User Has been registered as Doctor
 * @return {object} 400 - User Already Registered
 * @example response - 400 - Already Registered
{
    "message": "Doctor Already Registered"
}
@security bearerAuth
 * @example response - 200 - Registered
{
    "message": "Doctor Registered Successfully"
}
 * @returns 500 - Internal Server Error
 */
App.post(
  "/doctor/register",
  AuthenticatedRequest,
  upload.single("pdfFile"),
  async (req, res) => {
    // Check if the file is a pdf
    if (req.file?.mimetype != "application/pdf") {
      res.status(400).json({
        message: "Invalid File Type",
      });
      return;
    } else {
      // Check if the user is already registered
      if (req.User.ProfileType != null) {
        res.status(400).json({
          message: "User Already Registered",
        });
        return;
      } else {
        // Check if the request is valid
        const body = req.body as {
          speciality: string;
          experience: string;
          about: string;
        };
        if (
          body.speciality == null ||
          body.experience == null ||
          body.about == null
        ) {
          res.status(400).json({
            message: "Invalid Request",
          });
          return;
        } else {
          //  Insert the Doctor
          const DoctorInsert = await db.insert(DoctorTable).values({
            about: body.about,
            experience: body.experience,
            fileVerification: req.file.filename,
            speciality: body.speciality,
            user_id: req.User.id,
          });
          const UserUpdate = await db
            .update(userTable)
            .set({
              userType: "doctor",
            })
            .where(eq(userTable.id, req.User.id));
          if (DoctorInsert.rowCount > 0 && UserUpdate.rowCount > 0) {
            res.status(201).json({
              message: "Doctor Registered Successfully",
              status: "PENDING",
            });
          } else {
            res.status(500).json({
              message: "Internal Server Error",
            });
          }
        }
      }
    }
  }
);

const PORT = process.env.PORT || 3000;

App.listen(PORT, () => {
  console.log("Server is running on port ", PORT);
});

declare global {
  namespace Express {
    interface Request {
      User: User;
      Session: Session;
    }
  }
}

async function AuthenticatedRequest(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const sessionId = lucia.readSessionCookie(req.headers.cookie ?? "");
  // const authorizationHeader = req.headers.authorization;
  // const sessionId = lucia.readBearerToken(authorizationHeader ?? "");
  if (!sessionId) {
    res.status(400).json({
      message: "Unauthenticated Request",
    });
    return;
  }

  const { session, user } = await lucia.validateSession(sessionId);
  if (session == null && user == null) {
    res.status(401).json({
      message: "Unauthorized Request",
    });
    return;
  } else {
    req.User = user;
    req.Session = session;
    next();
  }
}
